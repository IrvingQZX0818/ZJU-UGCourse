# 操作系统小组调研报告——Docker原理概述

|组号|组名|小组成员|
|:-:|:-:|:-:|
|13|巴啦啦小魔仙|余锦成、刘琦、吴江、袁玉聪|

## Docker简介
Docker是一款开源软件，可以为Linux操作系统提供新的抽象和虚拟层，隔离了在同一个操作系统内不同的“容器”的运行环境，同时避免了运行累赘的虚拟机。[^Docker]

### Docker的优势
Docker为容器提供了一个隔离的运行环境，这个工作跟虚拟机差不多——虚拟机也是提供给应用程序一个隔离的运行环境。但是对比虚拟机，Docker并没有重新虚拟出一个操作系统，只是隔离了应用程序的集合（就是容器），这种实现使得Docker的容器对比虚拟机有启动效率更高，资源利用率更高的优势。
有了Docker，开发者可以把自己的应用程序打包成一个Docker镜像，然后就可以在不同的机器上运行，不需要考虑依赖和兼容的问题，并且应用程序运行在一个沙箱内，无须担心冲突和安全等问题。
下表是Docker和虚拟机的性能对比[^DockerVsVM]
|特性|容器|虚拟机|
|:-|:-|:-|
|启动时间|秒级|分钟级|
|硬盘使用|一般为MB|一般为GB|
|性能|接近原生|弱于原生|
|系统支持量|支持上千个|一般为几十个|

### Docker组成部分
Docker采用的是C/S架构。一个Docker有服务器端和客户端。这使得远程维护更加方便快捷。服务端和客户端采用的是TCP/IP协议进行数据传输。
客户端就相当于一个终端可以控制、访问服务端和容器和镜像。
服务端给客户端提供服务，并且实际运行和维护各类容器和镜像。服务端可以细分为一下部分：
- 镜像
镜像存放的是固有不变的只读数据。打个比方就是装系统时候需要下载的iso文件一样的东西。里面有这个镜像正常运行依赖的各种文件。
- 容器
容器是实际运行起来的镜像。容器和镜像的关系可以类比成OOP里面的实例和类。一个镜像可以创建出多个容器。就像一个iso文件可以装出多个虚拟机出来。然后这些虚拟机可以互相独立地运行。
- 仓库
仓库用于存放各种的镜像。Docker服务器可以从仓库中下载镜像用于创建运行容器。有了容器，发布镜像就变得很简单了。

## 镜像原理概述
原始虚拟机的数据储存特点就是使用虚拟磁盘技术。这种技术目前已经比较成熟了，动态分配磁盘空间技术已经被广泛使用，这使得虚拟机的磁盘占用降低了很多。
但是原始虚拟机的问题在于，两个完全相同的系统不能共享相同的文件，这使得储存冗余还是很大程度上降低了磁盘利用率。
Docker不同于传统虚拟机的一个特点就是其储存方式上面有很大不同。Docker采用了`UnionFS`技术，把镜像进行分层是处理。[^DockerFileSystem]
- `Union Fs`
    所谓的`Union FS`，就是把不同的目录挂载同一个目录下面，并且使用层的概念来解决权限、文件冲突和读写问题。
    - 结构
    `Union FS`用图画出来想像一个树状的结构。节点的继承关系根据挂载顺序决定。子节点拥有父节点的文件，不同子节点可以共享父节点，里面的文件内容也共享，如果父节点中文件内容发生改变，子节点的文件内容也会发生改变。如下图，是一个型的`Union Fs`目录结构。
        ```mermaid {align="center"}
        graph TD;
        Dir1-->Dir2;
        Dir2-->Dir3;
        Dir2-->Dir4;
        ```
        这个图里面，`Dir3`和`Dir4`是叶节点目录。在这两个目录中都可以看到`Dir1`和`Dir2`目录中的文件。同理，在`Dir2`中可以看到`Dir1`中的内容。但是`Dir3`和`Dir4`中可能有不同的文件。
        如果`Dir1`或者`Dir2`中的某个文件被修改，`Dir3`和`Dir4`中的文件也会同样进行修改（除非在`Dir3`或者`Dir4`中这个文件已经被覆盖了）。

    - 文件同名覆盖
    在继承时候，很容易父子节点的目录中有相同的文件。这时候`Union FS`会把子节点的这个文件覆盖掉父节点中的这个文件，父节点中的这个文件其实被隐藏了，在后继节点中就不能读到父节点的文件内容了。当然这时候修改父节点的内容，子节点的内容也不会发生改变。在子节点中的文件
    再用上例，在`Dir1`和`Dir2`中如果同样拥有`File`文件，两者文件内容分别为`File in Dir1`和`File in Dir2`。这样在`Dir2`、`Dir3`和`Dir4`中都只能看到`File`的文件内容为`File in Dir2`，`Dir1`中的文件内容只在`Dir1`中才可见。
        ```mermaid {align="center"}
        graph TD;
        Dir1-->Dir2;
        Dir1-.->|File| F1(File in Dir1);
        Dir2-->Dir3;
        Dir2-->Dir4;
        Dir2-.->|File| F2(File in Dir2);
        ```
    - 挂载权限[^CoolShell]
    目录在使用`Union FS`挂载的时候，可以设置被挂载目录的读写性。
    不同的`Union FS`可能有不同的实现。Docker中推荐使用的是`AUFS`，这里使用`AUFS`用来举例。[^AUFS]
    `AUFS`挂载的目录主要有三种挂载权限：
        - `rw`表示可读可写。在子节点中操作有可能会在这个目录中写入东西。
        - `ro`表示只读。子节点中的操作不会影响到这个目录。但是这个目录可能通过其他方式修改，这时候目录的修改在子节点中还是可以看到的。
        - `rr`表示真只读。一般用于本来就只读的目录，如iso文件或者CD ROM文件。这时候`AUFS`不会去检测目录的修改。也就是说这个目录被其他方式修改之后，子节点不会收到更新。

        默认情况下，第一个被挂载的目录为`rw`方式，其后的目录为`ro`方式。
    - 文件修改
    对文件的修改，`Union FS`采用的是`COW`策略，即修改文件时候才把文件拷贝到`rw`的子目录下。然后进行修改。这时候子目录的文件就可以覆盖掉父目录的内容了。删除文件则采用在`rw`子目录下对这个文件进行特殊标记，表明这个文件在这一层时候已经被删除了。这样在子目录下就不会出现这个文件了。
    在`AUFS`的实现中，使用一种`white-out`方式，在`rw`子目录中创建一个隐藏的带有`wh`前缀的文件表明文件被删除。
    因为Docker推荐使用`AUFS`，我们这里可以再对`AUFS`稍微详细地进行说明。[^AUFS]默认情况下`ro`属性的目录是没有`white-out`属性的。也就是说在`ro`目录下，即时有`white-out`标记的隐藏文件，可是不会生效的，必须在`rw`目录下面的才有效。当然也可以个`ro`目录赋予`wh`属性，这样这个`ro`目录下面的`wh`标记文件就能生效了。
    另外如果有多个目录挂载为`rw`，文件的创建修改应用在哪个目录可以有不同的策略进行控制。
    关于`AUFS`的更多叙述，可以查看我们展示中的所附Demo视频。
- 镜像结构
Docker镜像采用`Union FS`技术进行储存和挂载。这使得大量镜像可以复用同一个镜像的文件内容，这样使得镜像的总体大小有了大幅度下降。
比如说，很多Docker镜像都是基于`Ubuntu`或者`Debian`发行版的。这时候可以把`Ubuntu`或`Debian`发行版的核心文件作为一个镜像发布出来，这样其他镜像可以把它当做基础镜像搭建自己的镜像，这样自己的镜像就少了整整一个`Ubuntu`发行版的大小！
另外这些基础镜像应该避免被修改，因为对基础镜像的修改可能会影响到其他使用该基础镜像的无关镜像，会导致不可预料的结果。这就是为什么Docker的镜像被设置为只读。
另外还有一个好处，因为Docker镜像天然只读，在使用`AUFS`时候可以设置挂载方式为`rr`，这样可以使获得更好的读取性能。
- 数据卷
镜像是只读的，那么在创建容器时，容器创建、修改的文件放在哪里呢？答案是数据卷。
数据卷相当于`Union FS`中的最底层的读写层，容器所做的修改就会写入这个数据卷中。
数据卷分为两类：匿名卷和命名卷。
    - 匿名卷
    顾名思义，是没有名字的数据卷。在创建一个容器的时候，Docker为了让这个容器可以修改其文件系统内的东西，会给它默认分配一个匿名卷。匿名卷在容器结束运行后也会相应被删除。所以容器在重新打开的时候会重新分配一个匿名卷，这个容器不会有上一次运行它的镜像的容器的内容。
    - 命名卷
    命名卷就是用户手动分配了名字的数据卷。这个数据卷容器结束运行后不会被删除，所以可以在下次创建容器时候再次分配这个数据卷，这样容器就有了上次运行后的内容了。当然，命名卷也可以同时分配给两个同时运行的不同的容器，这样两个容器之间就可以通过文件进行数据交换了。

    但是使用数据卷不是Docker官方推荐的最佳实践，因为数据卷中可能有很多无关的文件等，使得数据卷大小庞大，而且是独立于容器存在的，管理起来很困难。
    官方的推荐做法是把主机目录挂载到容器中，这样在容器中某个指定目录的写入会直接写入到对应的主机目录中。这样维护起来就更加方便了。

### 容器原理概述

前文已经说过，容器可以说是镜像的实例，Docker中的应用程序实际上是运行在一个容器内。在这个容器中的进程有自己的root文件系统、网络配置、进程空间等，与其他容器互相隔离。而进程自身则认为自己运行在一个虚拟机中。但是与虚拟机不一样的是，进程是直接运行在宿主机内核上的，所以运行速度相当接近原生进程，而启动容器也只是新建几个名称空间而已，所以启动速度非常快。
这里简述一下容器的底层实现。
- 命名空间[^namespace]
命名空间是Linux内核提供的进程隔离的系统调用。在同一个命名空间的进程互相可以感知，但是对外界却一无所知。
Linux提供以下六种命名空间：
    - `UTS`：主机名和域名命名空间。这个命名空间使容器拥有独立的主机名和域名，让它可以在网络上被视为一个独立的节点。
    - `PID`：进程号名称空间。Linux内核里面每个内核都有一个独一无二的进程号。在容器中，我们也需要让容器内的进程重新标号。在Linux内核中的进程号命名空间，父命名空间可以访问子命名空间，但是反过来却不可以，这非常适合容器的隔离。
    - `IPC`：信号量、消息队列和共享内存命名空间。在Linux操作系统内，进程间的通讯方式常用的包括信号量、消息队列和共享内存。但是在容器中，这种通讯方式如果跟宿主机有相同的命名空间，容器内的进程就可能获取容器外的消息，也有可能外泄消息。有了IPC命名空间的隔离之后，这些消息就被完全隔离开了。
    - `Mount`：文件挂载和文件系统命名空间。有了这个命名空间之后，容器就可以有自己root文件系统，这样对根目录的操作就不会影响到宿主机了。此外，也可以避免挂载名字冲突等问题，使用命名空间比使用`chroot`隔离程度更好。
    - `User`：用户和用户组命名空间。这个命名空间可以让容器有自己的`root`用户和其他用户，可以防止用户名和用户组冲突。也可以避免运行容器时候修改宿主机的用户和用户组。
    - `Network`：网络命名空间。网络命名空间可以让容器内部的进程进行套接字通讯时候不用占用宿主机的端口，还方便对容器内部的端口进行映射，使得同一个镜像运行多个容器时候不用考虑端口冲突的问题。

    有了这六个内核层面支持的命名空间，容器可以很高效方便地对容器进行非常安全、彻底的隔离。
- 控制组[^cgroup]
通过命名空间之后，我们就可以实现容器与宿主机的隔离了。但是对比虚拟机还有一个不足的地方，就是对容器的控制。现在容器内的进程是直接运行在宿主机内核中的，那么这些进程还是可以尽情地“榨取”宿主机的资源：比如内存、CPU等。为了解决资源控制的问题，Docker采用了Linux内核中提供的cgroup框架。
所谓的cgroup，就是control group的意思。可以把一系列进程放入一个控制组中进行控制，包括控制CPU使用、内存使用、硬件资源使用、进程状态，还有资源统计，进程优先级分配等。
因为之前已经有小组讨论过这个话题，所以这次小组讨论并没有太过于深入研究cgroup的机制。但是可以得出结论的是：Docker使用cgroup对容器进行资源和状态的控制，防止容器占用过多的系统资源，保证了容器之间资源的公平和可调控性和可配置性。

- 容器初始化[^init]
容器创建时候，需要创建容器，创建命名空间、创建cgroup、挂载root文件系统、执行进程等。那么具体是如何完成的呢，这里我们对容器的初始化进行简述：
    - 使用`clone()`系统调用创建新的名称空间并创建子进程。该子进程在容器中的pid为1，是容器的`init`进程。
    - 在容器进行初始化时候，父进程和容器的`init`进程使用管道进行通讯。并且子进程等待父进程初始化完成的消息。
    - 父进程创建uid/gid映射，并把子进程放入新的cgroup中。
    - 父进程创建完成后，通过管道告诉子进程初始化完成。
    - 子进程挂载文件系统，并且初始化各种设备。
    - `init`进程清理现场，然后调用`exec()`执行目的进程。

    在容器创建完成之后，Docker同样可以创建新的进程，并且放入容器的命名空间和cgroup中，然后执行进程，这样就可以在容器中运行新的程序了。
    这里有几点值得注意的是，容器中pid为1的进程，跟传统的pid为1的进程一样，在该PID命名空间中是拥有特权的。所以如果在docker中运行一个shell，那么这个shell将会是容器中的root shell。
    初始化容器时候，创建的子进程由于进行了名称空间的隔离，所以与父进程的通讯使用套接字已经不可行了，使用信号也显得难以实现。而使用轮询效率底下。所以使用管道是最为适合的通讯方法。[^source]

## 总结

本次调研研究和讨论了Docker的简单实现原理，了解了Docker在镜像储存空间上使用`Union FS`的优化，在容器隔离和控制中使用了命名空间和控制组，理解Docker中的进程实际上是运行于宿主机内核中的特殊进程，解释了Docker为何比虚拟机更加节省磁盘、启动和运行效率更高。
同时在调研过程中，对Linux操作系统的进程管理、文件系统等的理解更加深入，同时也让我们学会了使用Docker这个新生却强大的工具，为我们以后工作科研起了很好的奠基作用。

## 引用
[^Docker]: [Docker (software) - Wikipedia](https://en.wikipedia.org/wiki/Docker_(software))
[^DockerVsVM]: [Docker —— 从入门到实践](https://www.gitbook.com/book/yeasy/docker_practice)
[^DockerFileSystem]: [剖析Docker文件系统：Aufs与Devicemapper](http://www.infoq.com/cn/articles/analysis-of-docker-file-system-aufs-and-devicemapper)
[^CoolShell]: [DOCKER基础技术：AUFS](https://coolshell.cn/articles/17061.html)
[^AUFS]: [aufs](http://aufs.sourceforge.net/aufs2/man.html)
[^namespace]: [Docker背后的内核知识——Namespace资源隔离](http://www.infoq.com/cn/articles/docker-kernel-knowledge-namespace-resource-isolation)
[^cgroup]: [Docker背后的内核知识——cgroups资源限制](http://www.infoq.com/cn/articles/docker-kernel-knowledge-cgroups-resource-isolation)
[^init]: [Docker背后的容器管理——Libcontainer深度解析](http://www.infoq.com/cn/articles/docker-container-management-libcontainer-depth-analysis)
[^source]: [Docker源码分析](https://www.amazon.cn/dp/B012ROMRUM/)